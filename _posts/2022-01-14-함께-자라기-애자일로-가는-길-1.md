---
layout: post
title: "함께 자라기: 애자일로 가는 길 1"
date: 2022-01-14 19:38:51.943 +0900
categories: Study Agile
tags: agile
---

### 야생 학습

학교에선 다음과 같은 것들이 있었다. 

- 커리큘럼, 시험, 범위, 정답, 목표


그러나 살아가면서 무의식적으로 하는 학습들은 이런 것과는 거리가 멀다. 이것들을 **야생 학습** 이라 하겠다. 실은 이런 학습이 이 책에서 다루고자 하는 종류의 학습이다.
학교를 졸업하고서도 이런 *학교 학습 전략* 을 고수하면서 힘들어진다. 이 책에서는 의식적으로 야생 학습을 하는 방법을 학습해보고자 하는 취지다.


### 1만 시간의 법칙

> 55년 동안 걸었다고 걷는 게 점점 나아지는 게 아니다. 즐기는 것을 한다고 해서 더 뛰어나질 것이라는 믿음믄 미신 - Anders K. Ericsson

1만 시간의 법칙에서 1만 시간은 **자신의 기량을 향상시킬 목적으로 반복적으로 하는 (의도적인) 수련**. 업무를 하면서도 이런 수련을 할 수 있는 방법이 바로 애자일 철학을 활용하는 것.

애자일 방법론에선 내 행위의 피드백을 10분 후, 한 시간 후, 하루 후, 일주일 후 등 여러 주기를 통해 지속적으로 얻을 수 있다. 실수의 빠른 교정이 가능해 지는 것.

애자일 방법론에서는 학습을 소프트웨어 개발의 가장 큰 병목으로 본다. 학습에서는 피드백이 중요한데, 이를 애자일 방법론을 통해 학습 효과가 극대화된다.


### 자기계발은 복리로 돌아온다

작년 본인에게 얼마나 투자했는가? 하루 한시간은 투자하라. 그렇지 않으면 직장인 기준 하위 1/3.

- 이미 가지고 있는 것을 잘 활용해라. 촘촘히 엮어서 길을 닦고, 새로운 것과 갖고 있던 것을 충돌시켜보아라. 그래서 체화하라.
- 나의 일(A)을 좀 더 효율적으로 개선하는 일(B)을 하라. 개선하는 일(B) 자체를 더 잘 할 수 있도록 개선하는 일(C)을 하라. 복리의 비밀.
- 피드백을 자주 받아라. 크고 완벽한 사이클보다 작고 잦은 실패의 사이클을 반복하라.
- 자신의 능력을 높여줄 도구를 점진적으로 만들어라. 완벽한 도구와 환경에 집착하지 말아라.


### 배우기 힘든 직업이 살아남는다

알파고가 학습에 유리한 조건

- 참고할 자료가 많고, 선택지가 유한하며, 목표가 확실하고, 성취도를 쉽게 확인 가능함.

이는 사람도 학습하기 유리한 환경이다. 그리고 이를 뒤집으면 학습하기 어려운, 이른바 직관의 영역, 회색이다.

- 자료도 없고, 선택지도 불확실하며, 목표가 동적이고, 피드백 받기 어렵다. 성취도란게 없음.

이런 영역의 직업은 실제로 평균 임금도 높다. 예시로 *컴퓨터 프로그래머(코더 - 에 가까운)* 와 *소프트웨어(애플리케이션) 개발자*를 비교해보자. 여기서 전자는 스팩대로 코드를 작성하는 직무이며, 후자는 소프트웨어를 뭘 만들지 고민하면서 타인과 상호작용하는 부분이 많은 직무로 구분. 중요한 건 명칭이 아니다. 매일 하는 일이 어떤 성격인가? 전자에 가까울 수록 인공지능에 대체될 위험이 크다. 학습이 어려운, 직관의 영역을 넘나드는 사람들이 경쟁력을 가질 것.


### 달인이 되는 비결 - 단순 반복은 답이 아니다.

- 개선하려는 동기, 적절한 타이밍의 피드백

전문성의 직관은 타당성과 피드백이 필요하다. 이 두 가지가 없다면, 결코 전문성을 가질 수 없다. 조금이라도 예측 가능한(포커 같은) 일이면서, 자신이 한 일의 결과를 빠르게 알 수 있는 환경(외과의사)이어야 전문성을 기를 수 있다. 그런 면에서 소프트웨어 개발은 이 둘 모두 부족하다. 그러면 어떻게?


### 방식을 바꿔라

- 타당성을 높여라: 변수를 제한하고 실험을 하면서 규칙성과 인과관계를 찾는 노력을 하라
- 피드백을 잦게: 소프트웨어 사용자에게 피드백을 적극적으로 구하라


### 의도적 수련의 필요조건: 지루함과 불안함의 사이에서 몰입하라

0. 지루한가? 스스로의 능력을 제한하라: 디버거 안쓰기, 컴파일 주기 늘리기
0. 지루한가? 난이도를 높여라
    * 일정보다 더 빨리 완료해보자
    * 스펙보다 더 고성능으로 구현해보자
    * 개발 언어를 바꿔보자
    * 공식적으론 안 해도 되는 일을 추가적으로 해보자 (잡 크래프팅 \ 자기주도성)
        0. 리팩토링
        0. 자동화 테스트 추가
        0. 자신만의 도구를 개발(매우 중요)
0. 불안한가? 
    * 사회적 접근: 전문가의 도움을 받아라 - 짝(pair) 프로그래밍, 커뮤니티 질문, 튜토리얼 따라하기
    * 도구적 접근: 괜찮은 디버거, 오픈소스 라이브러리
    * 내관적 접근: 자신의 경험을 되살려 보기
0. 불안한가?
    * 구현하고자 하는 기능의 알파 버전을 만들어 보라([WTSTTCPW](https://www.artima.com/articles/the-simplest-thing-that-could-possibly-work){:target="_blank" }).

### 스스로의 실력이나 작업의 난이도는 계속 바뀐다

끊임없이 자신의 감정이나 상태를 살피고 이를 동적으로 균형을 맞춰야 한다. **메타인지**.
예를 들어 TDD를 잘 하려면 이런 균형을 잘 맞춰야 지속적인 몰입을 경험하면서 자라날 수 있다.


### 전문가로부터 전문성 끌어내기

전문가에게 어떻게 전문성을 얻게 되었는지 묻는 것은 효과적이지 않다. 실제로 어떻게 하는지를 보고 역으로 분석하라. Reverse Engineering. 유명한 오픈소스 프로그래머에게 얻어낸 **프로그래밍 언어를 빠르게 배우는 전문성**을 분석했을 때, 그분은 먼저 word count 프로그램을 만들 목적으로 튜토리얼을 봤다. 그러다 어느 정도 코드를 짤 만큼 봤다면, 바로 해당 프로그램을 짜기 시작했다. 이것만으로 당연히 충분하지 않기 때문에, 해당 언어의 표준 라이브러리 소스 코드를 읽었다. 이걸 통해 해당 프로그래밍 언어의 결을 알 수 있고, 언어 개발자가 지향하는  스타일과 숙어를 알게 된다. 동시에 실질적인 사용 예를 찾아 직접 찾아내 구현했다. 자신이 만들 수 있는 작고 간단한 추가 기능을 생각해낸 것이다. 이런 실험을 통해 빠르게 피드백을 받을 수 있었다.


### 실수를 관리하라. 예방하지 말아라.

실수를 관리하는 조직은 실수를 통해 꾸준히 학습하는 데에 익숙하다. 고로 보다 혁신적이다.


### 뛰어난 선생?

전문가들은 오히려 많은 부분이 자동화되어 있기 때문에 자신이 아는 것의 30%만 가르치고는 전부 가르쳤다고 여긴다. 학생들의 성취도에 크게 관여하는 능력은 선생이 다음 질문에 얼마나 더 잘 답하냐 - "내가 이 문제를 해결할 때 어떤 과정을 거치는가". 메타분석.


### 전문가 === 고독한 천재?

현실에서의 전문성은 사회적 장치도 필요하다. 어떤 기술적 실천법이어도 이를 현실에 적용하기 위해서는 사회적 자본과 기술이 필요하다. 사회적 자본으로 *신뢰*를 들면, 신뢰가 없으면 뭘 하든 고깝게 보일 것이다. 전문가는 사회적 자본과 기술 또한 뛰어나다. 초보 개발자에게 조언할 때 단순히 기술적인 조언만 하는 것이 아니란 뜻이다. 당신이 전문가라면, 팀의 조직원들이 당신을 좋아하는가? 


